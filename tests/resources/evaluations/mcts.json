{
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            next_node = min(available_nodes, key=lambda x: distance_matrix[current_node][x])\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 6.1970213368273175,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    probabilities = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                probabilities[i][j] = 1 / distance_matrix[i][j]\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            next_node = np.random.choice(available_nodes, p=probabilities[current_node]/np.sum(probabilities[current_node]))\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": false,
    "obj": "inf",
    "traceback_msg": "Traceback (most recent call last):\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 57, in <module>\n    obj = solve(node_pos)\n          ^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 28, in solve\n    heu = heuristics(dist_mat.copy()) + 1e-9\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/gpt.py\", line 19, in heuristics\n    next_node = np.random.choice(available_nodes, p=probabilities[current_node]/np.sum(probabilities[current_node]))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"numpy/random/mtrand.pyx\", line 987, in numpy.random.mtrand.RandomState.choice\nValueError: 'a' and 'p' must have same size\n"
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            probabilities = distances / np.sum(distances)\n            next_node = np.random.choice(available_nodes, p=probabilities)\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 26.559761418702244,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            next_node = min(available_nodes, key=lambda x: distances[available_nodes.index(x)])\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 6.227206945675301,
    "traceback_msg": null
  },
  "import numpy as np\nimport random\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n\n    # Generate a random initial solution\n    current_solution = list(range(n))\n    random.shuffle(current_solution)\n    current_cost = sum(distance_matrix[current_solution[i]][current_solution[(i+1)%n]] for i in range(n))\n\n    # Local search to refine the solution\n    for _ in range(n*n):\n        i, j = random.sample(range(n), 2)\n        new_solution = current_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_cost = sum(distance_matrix[new_solution[k]][new_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost < current_cost:\n            current_solution = new_solution\n            current_cost = new_cost\n            heuristics_matrix[current_solution[i]][current_solution[j]] += 1\n            heuristics_matrix[current_solution[j]][current_solution[i]] += 1\n\n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 14.049269657107136,
    "traceback_msg": null
  },
  "import numpy as np\nimport random\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n\n    # Generate a random initial solution\n    current_solution = list(range(n))\n    random.shuffle(current_solution)\n    current_cost = sum(distance_matrix[current_solution[i]][current_solution[(i+1)%n]] for i in range(n))\n\n    # Local search to refine the solution\n    for _ in range(n):\n        for i in range(n):\n            for j in range(i+1, n):\n                new_solution = current_solution.copy()\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_cost = sum(distance_matrix[new_solution[k]][new_solution[(k+1)%n]] for k in range(n))\n\n                if new_cost < current_cost:\n                    current_solution = new_solution\n                    current_cost = new_cost\n                    heuristics_matrix[current_solution[i], current_solution[j]] += 1\n                    heuristics_matrix[current_solution[j], current_solution[i]] += 1\n\n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 13.325444716140918,
    "traceback_msg": null
  },
  "import numpy as np\nimport random\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        current_node = np.random.choice(range(n))\n        available_nodes = list(range(n))\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            i, j = random.sample(range(n), 2)\n            new_solution = current_node\n            new_solution = current_node.copy()\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            \n            current_cost = sum(distance_matrix[current_solution[k]][current_solution[(k+1)%n]] for k in range(n))\n            new_cost = sum(distance_matrix[new_solution[k]][new_solution[(k+1)%n]] for k in range(n))\n            \n            if new_cost < current_cost:\n                heuristics_matrix[current_node][new_solution[i]] += 1\n                heuristics_matrix[new_solution[i]][current_node] += 1\n                current_node = new_solution[i]\n                available_nodes.remove(new_solution[i])\n            else:\n                break\n    \n    return heuristics_matrix": {
    "exec_success": false,
    "obj": "inf",
    "traceback_msg": "Traceback (most recent call last):\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 57, in <module>\n    obj = solve(node_pos)\n          ^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 28, in solve\n    heu = heuristics(dist_mat.copy()) + 1e-9\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/gpt.py\", line 17, in heuristics\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                                       ~~~~~~~~~~~~^^^\nIndexError: invalid index to scalar variable.\n"
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            next_node = max(available_nodes, key=lambda x: heuristics_matrix[current_node][x] * (-1))\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 21.06011612502359,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            next_node = min(available_nodes, key=lambda x: distance_matrix[current_node][x] / (1 + heuristics_matrix[current_node][x]))\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 6.494246479304124,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            edge_probabilities = np.ones(len(available_nodes)) \n            edge_probabilities /= np.sum(edge_probabilities)\n            next_node = np.random.choice(available_nodes, p=edge_probabilities)\n            \n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            \n            # Adjust edge selection probabilities\n            edge_probabilities += 1\n            edge_probabilities /= np.sum(edge_probabilities)\n            \n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 21.737547026425,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            next_node = max(available_nodes, key=lambda x: distance_matrix[current_node][x])\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 34.08222482819301,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    \n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            weighted_distances = [distance_matrix[current_node][x] / heuristics_matrix[current_node][x] for x in available_nodes]\n            next_node = available_nodes[np.argmin(weighted_distances)]\n            \n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 25.2674221089324,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        current_node = np.random.randint(n)\n        available_nodes = list(range(n))\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            next_node = available_nodes[np.argmin(distances)]\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 6.201902705091685,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            prob_weights = [1 / (1 + heuristics_matrix[current_node][x]) for x in available_nodes]\n            next_node = np.random.choice(available_nodes, p=prob_weights)\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": false,
    "obj": "inf",
    "traceback_msg": "Traceback (most recent call last):\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 57, in <module>\n    obj = solve(node_pos)\n          ^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/eval.py\", line 28, in solve\n    heu = heuristics(dist_mat.copy()) + 1e-9\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Users/hwr/projects/llamda/llamda/problems/tsp_aco/gpt.py\", line 15, in heuristics\n    next_node = np.random.choice(available_nodes, p=prob_weights)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"numpy/random/mtrand.pyx\", line 994, in numpy.random.mtrand.RandomState.choice\nValueError: probabilities do not sum to 1\n"
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            attractiveness = [distance_matrix[current_node][x] / (1 + heuristics_matrix[current_node][x]) for x in available_nodes]\n            next_node = available_nodes[np.argmax(attractiveness)]\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 27.95969747115212,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            frequencies = [heuristics_matrix[current_node][x] for x in available_nodes]\n            combined_score = [(1 - 0.1) * distances[i] + 0.1 * frequencies[i] for i in range(len(distances))]\n            \n            next_node = available_nodes[np.argmin(combined_score)]\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 8.507394751959112,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            counts = [heuristics_matrix[current_node][x] + heuristics_matrix[x][current_node] for x in available_nodes]\n            scores = [distances[i] / counts[i] if counts[i] > 0 else distances[i] for i in range(len(available_nodes))]\n            next_node = available_nodes[scores.index(min(scores))]\n            \n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 6.272224564775536,
    "traceback_msg": null
  },
  "import numpy as np\n\ndef heuristics(distance_matrix):\n    n = len(distance_matrix)\n    heuristics_matrix = np.zeros((n, n))\n    \n    for _ in range(n):\n        available_nodes = list(range(n))\n        current_node = np.random.choice(available_nodes)\n        available_nodes.remove(current_node)\n        \n        while available_nodes:\n            distances = [distance_matrix[current_node][x] for x in available_nodes]\n            heuristics_row = heuristics_matrix[current_node]\n            heuristic_scores = [1 / (1 + heuristics_row[x]) + 1 / (1 + distances[i]) for i, x in enumerate(available_nodes)]\n            next_node = available_nodes[np.argmax(heuristic_scores)]\n            heuristics_matrix[current_node][next_node] += 1\n            heuristics_matrix[next_node][current_node] += 1\n            available_nodes.remove(next_node)\n            current_node = next_node\n    \n    return heuristics_matrix": {
    "exec_success": true,
    "obj": 8.248387213682896,
    "traceback_msg": null
  }
}