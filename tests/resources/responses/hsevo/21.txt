```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Enhanced heuristic combining the influence of distance, node connectivity, 
    and minimum edge evaluation to better assess promising edges for the TSP.
    """
    
    num_nodes = distance_matrix.shape[0]
    
    # Calculate the mean and median distance for each node to assess overall connectivity
    mean_distances = np.mean(distance_matrix, axis=1)
    median_distances = np.median(distance_matrix, axis=1)

    # Calculate connectivity based on the count of non-infinite distances
    connectivity_scores = np.count_nonzero(distance_matrix, axis=1) / num_nodes

    # Calculate inverse distance metrics
    with np.errstate(divide='ignore', invalid='ignore'):
        inverse_distances = np.where(distance_matrix > 0, mean_distances[:, np.newaxis] / distance_matrix, 0)

    # Combine factors: prioritizing edges with lower distances and higher connectivity
    promising_scores = (inverse_distances ** 2) * connectivity_scores[:, np.newaxis]
    
    # Calculate minimum edges for each node to enhance local connectivity emphasis
    min_edges = np.min(distance_matrix + np.eye(num_nodes) * np.inf, axis=1)
    min_edges_matrix = min_edges[:, np.newaxis] / distance_matrix

    # Factor in the minimum edges to prioritize local paths
    promising_scores *= min_edges_matrix

    # Sparsify by zeroing out unpromising scores
    promising_scores[promising_scores < 0.05] = 0
    
    # Ensure diagonal entries (self-loops) are zero
    np.fill_diagonal(promising_scores, 0)
    
    return promising_scores
```