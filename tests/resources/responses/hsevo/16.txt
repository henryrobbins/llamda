```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Combine simple inverse distance with normalization and sparsity for edge selection.
    Prioritizes shorter distances while avoiding complex transformations.
    """
    # Calculate the maximum distance for normalization
    max_distance = np.max(distance_matrix)
    
    # Inverse of the distance matrix to prioritize shorter distances
    inv_distance = 1 / distance_matrix
    
    # Normalize distances, but prevent negative values and ensure no self-loops
    with np.errstate(divide='ignore', invalid='ignore'):
        normalized_distances = np.where(distance_matrix > 0, 1 - (distance_matrix / max_distance), 0)
    
    # Combine inverses with normalized scores
    combined_scores = inv_distance * normalized_distances
    
    # Set diagonal entries (self-loops) to zero to avoid self-selection
    np.fill_diagonal(combined_scores, 0)
    
    # Sparsify by thresholding low scores to zero
    threshold = np.mean(combined_scores[combined_scores > 0])  # Can adjust threshold as necessary
    combined_scores[combined_scores < threshold] = 0
    
    return combined_scores
```