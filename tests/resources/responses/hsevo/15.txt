```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic design combining simplicity of inverse distance 
    with a mean distance prioritization to enhance promising edge identification.
    """
    
    # Calculate the mean distance for each node
    mean_distances = np.mean(distance_matrix, axis=1)

    # Calculate the inverse of distances while avoiding infinity values
    with np.errstate(divide='ignore', invalid='ignore'):
        inverse_distances = np.where(distance_matrix > 0, mean_distances[:, np.newaxis] / distance_matrix, 0)
    
    # Generate promising scores by combining both approaches
    promising_scores = inverse_distances ** 2  # Introduce non-linearity for emphasis on shorter distances
    
    # Sparsify matrix by zeroing out unpromising scores (threshold can be adjusted for application)
    promising_scores[promising_scores < 0.1] = 0
    
    # Ensure diagonal entries (self-loops) are zero
    np.fill_diagonal(promising_scores, 0)
    
    return promising_scores
```