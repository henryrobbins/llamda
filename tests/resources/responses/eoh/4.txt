{
New algorithm: The heuristics function calculates prior indicators for each edge in a solution by sampling stochastic solutions and updating the indicators based on the total distance of each solution.
}

```python
import numpy as np

def heuristics(distance_matrix):
    n = len(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    for _ in range(n**2):
        path = np.random.permutation(n)
        total_distance = 0
        
        for i in range(n - 1):
            total_distance += distance_matrix[path[i]][path[i + 1]]
        
        total_distance += distance_matrix[path[-1]][path[0]]
        
        for i in range(n - 1):
            heuristics_matrix[path[i]][path[i + 1]] += 1/total_distance
            heuristics_matrix[path[i + 1]][path[i]] += 1/total_distance
        heuristics_matrix[path[-1]][path[0]] += 1/total_distance
        heuristics_matrix[path[0]][path[-1]] += 1/total_distance

    return heuristics_matrix
```