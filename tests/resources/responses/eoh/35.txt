The common backbone idea in the provided algorithms is to transform the distances in the distance matrix to heuristics values that indicate the desirability of including each edge in the solution.

{The new algorithm calculates the heuristics matrix by taking the product of the sine of the reciprocal of the distances in the distance matrix.}

```python
import numpy as np

def heuristics(distance_matrix):
    num_nodes = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((num_nodes, num_nodes))

    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                heuristics_matrix[i, j] = np.sin(1 / distance_matrix[i, j])

    return heuristics_matrix
```