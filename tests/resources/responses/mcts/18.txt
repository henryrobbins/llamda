{
The design idea of the new algorithm is to introduce a self-adjusting mechanism that updates the edge selection probabilities based on the historical edge choices, potentially favoring edges that have not been frequently selected, aiming to explore different paths efficiently.
}

```python
import numpy as np

def heuristics(distance_matrix):
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    
    for _ in range(n):
        available_nodes = list(range(n))
        current_node = np.random.choice(available_nodes)
        available_nodes.remove(current_node)
        
        while available_nodes:
            edge_probabilities = np.ones(len(available_nodes)) 
            edge_probabilities /= np.sum(edge_probabilities)
            next_node = np.random.choice(available_nodes, p=edge_probabilities)
            
            heuristics_matrix[current_node][next_node] += 1
            heuristics_matrix[next_node][current_node] += 1
            available_nodes.remove(next_node)
            
            # Adjust edge selection probabilities
            edge_probabilities += 1
            edge_probabilities /= np.sum(edge_probabilities)
            
            current_node = next_node
    
    return heuristics_matrix
```