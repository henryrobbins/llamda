{
The new algorithm introduces a modified selection mechanism where the next node is chosen based on a combination of the shortest distance from the current node and the frequency of visiting that node in previous iterations, aiming to balance exploration and exploitation during the solution sampling process.
}

```python
import numpy as np

def heuristics(distance_matrix):
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    
    for _ in range(n):
        available_nodes = list(range(n))
        current_node = np.random.choice(available_nodes)
        available_nodes.remove(current_node)
        
        while available_nodes:
            distances = [distance_matrix[current_node][x] for x in available_nodes]
            frequencies = [heuristics_matrix[current_node][x] for x in available_nodes]
            combined_score = [(1 - 0.1) * distances[i] + 0.1 * frequencies[i] for i in range(len(distances))]
            
            next_node = available_nodes[np.argmin(combined_score)]
            heuristics_matrix[current_node][next_node] += 1
            heuristics_matrix[next_node][current_node] += 1
            available_nodes.remove(next_node)
            current_node = next_node
    
    return heuristics_matrix
```