Common ideas in the No.1 algorithm:
- Random initial solution
- Local search refinement
- Updating heuristics matrix based on cost improvements

{Design idea: Combining random selection of starting node with iterative greedy selection of next nodes based on the distances, while updating the heuristics matrix to track promising edges like in the No.1 algorithm.}

```python
import numpy as np

def heuristics(distance_matrix):
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    
    for _ in range(n):
        current_node = np.random.randint(n)
        available_nodes = list(range(n))
        available_nodes.remove(current_node)
        
        while available_nodes:
            distances = [distance_matrix[current_node][x] for x in available_nodes]
            next_node = available_nodes[np.argmin(distances)]
            heuristics_matrix[current_node][next_node] += 1
            heuristics_matrix[next_node][current_node] += 1
            available_nodes.remove(next_node)
            current_node = next_node
    
    return heuristics_matrix
```